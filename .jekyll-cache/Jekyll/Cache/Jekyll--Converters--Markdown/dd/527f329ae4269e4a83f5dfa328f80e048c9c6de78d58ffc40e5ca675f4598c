I"c3<h1 id="병합-정렬-merge-sort">병합 정렬 (Merge Sort)</h1>

<p>자료 출처 : 나동빈님 블로그 (<a href="https://blog.naver.com/ndb796/221227934987">https://blog.naver.com/ndb796/221227934987</a>)</p>

<h2 id="일단-반으로-나누고-나중에-합쳐서-정렬하면-어떨까">“일단 반으로 나누고 나중에 합쳐서 정렬하면 어떨까?”</h2>

<blockquote>
  <p>배열을 앞 부분과 뒷 부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘</p>
</blockquote>

<ul>
  <li>이것도 퀵 정렬처럼 <strong>‘분할 정복’</strong> 방법을 채택한 알고리즘. 따라서 <strong>시간복잡도</strong> 역시 <code class="language-plaintext highlighter-rouge">O(N*logN)</code>이다</li>
  <li>그러나 퀵 정렬과 달리, 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(NlogN)을 보장한다.</li>
</ul>

<blockquote>
  <p>합치는 순간에 정렬을 수행한다</p>
</blockquote>

<p>합치는 단계는 3단계면 된다. 합치는 갯수는 1→2→4→8로 2배씩 증가. 즉 2^3=8이므로 3단계만 필요하다.</p>

<p>즉, 데이터의 갯수가 N개일 때 정렬 자체에 필요한 수행시간은  N(데이터 갯수만큼) , 높이는 logN(단계의 크기)으로 총 시간복잡도는 <strong>O(N*logN)</strong>이다.</p>

<h3 id="왜-정렬에-필요한-수행시간이-n일까">왜 정렬에 필요한 수행시간이 N일까?</h3>

<ul>
  <li>삽입 정렬과 마찬가지로 ‘부분 집합은 이미 정렬이 되어있는 상태’라고 <strong>가정</strong>하기 때문!</li>
</ul>

<p>이미 정렬된 상태의 두 배열을 정렬할 때 비교는 데이터 갯수 N번만큼만 하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">sort.merge</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="c1">// 병합정렬 알고리즘</span>
<span class="c1">// 전체 시간 복잡도는 O(n log n)</span>
<span class="cm">/* 배열의 요소 개수가 2개 이상인 경우
 	1. 배열의 앞부분을 병합 정렬로 정렬한다
 	2. 배열의 뒷부분을 병합 정렬로 정렬한다
 	3. 배열의 앞부분과 뒷부분을 병합한다
  */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">buff</span><span class="o">;</span>	<span class="c1">// 작업용 배열</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Scanner</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"병합 정렬"</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"요솟수 : "</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nx</span><span class="o">];</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"x["</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="s">"]: "</span><span class="o">);</span>
			<span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="o">}</span>
		
		<span class="n">mergeSort</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">nx</span><span class="o">);</span>	<span class="c1">// 배열 x를 병합정렬</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"오름차순으로 정렬했습니다"</span><span class="o">);</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"x["</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="s">"]= "</span><span class="o">+</span> <span class="n">x</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

		<span class="n">sc</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">buff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>		<span class="c1">//병합한 결과를 일시적으로 저장할 작업용 배열 생성</span>
		<span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>	<span class="c1">//실제로 정렬 작업을 수행할 __mergeSort()메서드를 호출하여 배열 전체를 병합 정렬한다</span>
		<span class="n">buff</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>			<span class="c1">// 작업용 배열을 해제</span>
	<span class="o">}</span>

	<span class="c1">// a[left] ~ a[right]를 재귀적으로 병합 정렬	// left=0, right:n-1</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">__mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
									<span class="c1">//a:정렬할 배열, left/right : 첫번째/마지막 요소의 인덱스</span>
		<span class="k">if</span><span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">center</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
			
			
			<span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">center</span><span class="o">);</span>	<span class="c1">// 배열의 앞부분 정렬</span>
			<span class="n">__mergeSort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">center</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span><span class="c1">// 배열의 뒷부분 정렬</span>
			
			<span class="c1">// 정렬 후 병합을 수행하는 코드</span>
			<span class="k">for</span><span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="n">left</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span> <span class="n">center</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>	<span class="c1">// 배열의 앞부분인 a[left]~a[center]을 buff[0]~buff[center-left]에 복사한다</span>
				<span class="n">buff</span><span class="o">[</span><span class="n">p</span><span class="o">++]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>			<span class="c1">// for문이 끝날 떄 p의 값은 복사한 요솟수 center-left+1이다</span>
			
			<span class="k">while</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">)</span>		<span class="c1">// 배열의 뒷부분인 a[center+1]~a[right]와 buff로 복사한 배열의 앞부분 p개를 병합한 결과를 배열a에 저장한다 </span>
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="o">(</span><span class="n">buff</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">?</span> <span class="n">buff</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">:</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
				
			<span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">)</span>
				<span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">++]</span> <span class="o">=</span> <span class="n">buff</span><span class="o">[</span><span class="n">j</span><span class="o">++];</span>		<span class="c1">// 배열 buff에 남아 있는 요소를 배열 a에 복사한다</span>
		<span class="o">}</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h1 id="병합-정렬을-구현할-때-신경써야-할-부분">병합 정렬을 구현할 때 신경써야 할 부분??</h1>

<ul>
  <li>위 코드의 buff처럼 정렬에 사용되는 배열은 전역 변수’로 선언되어야 한다.  병합 정렬은 ‘기존의 데이터를 담을 추가적인 배열 공간이 필요하다’는 점에서 메모리 활용이 <strong>비효율적</strong>이다.</li>
</ul>

<h2 id="병합-정렬은-일반적인-경우-퀵-정렬보다-느리지만-어떠한-상황에서도-정확히-onlogn을-보장할-수-있다는-점에서-몹시-효율적인-알고리즘이다">병합 정렬은 일반적인 경우 퀵 정렬보다 느리지만 어떠한 상황에서도 정확히 O(NlogN)을 보장할 수 있다는 점에서 몹시 효율적인 알고리즘이다.</h2>
:ET